(*
   Main ATD test file for atddiff. Newer version to be compared with
   the older version.

   backward-compatible = we can read old data with a newer implementation
   forward-compatible = we can read new data with an older implementation
   ...-incompatible = we can't ...
*)

(****************************************************************************)
(* Type definitions without breaking changes in any direction *)
(****************************************************************************)

type unchanged_variant = [
  | A
  | B of int
]

(* The order of the type definitions changed on purpose. *)
type unchanged_record = {
  a: int;
  ?b: int option;
  ~c: int list;
  d <new>: int <new2 a="b">;
  renamed_field_type: new_name_for_unchanged_type;
}

type new_name_for_unchanged_type = [ Thing ]

(****************************************************************************)
(* Type definitions with breaking changes *)
(****************************************************************************)

type backward_incompatible_record = {
  added_field: int;
  becomes_required: int;
  json_repr_changes: (string * int) list <json repr="object">;
}

type forward_incompatible_record = {
  ?becomes_optional: int option;
  json_repr_changes: (string * int) list <json repr="object">;
}

type backward_incompatible_record_if_implicit_defaults = {
  becomes_required: int;
}

type forward_incompatible_record_if_implicit_defaults = {
  ~becomes_optional: int;
}

type backward_incompatible_variant = [ A ]

type forward_incompatible_variant = [ A | B ]

type ('a, 'b) unchanged_type_parameters = { x: ('a * 'b) list }

type ('a, 'b) swapped_type_parameters = { x: ('b * 'a) list }

type 'a type_arity_changed = ('a * 'a) list

type 'a ignored_type_parameters_are_ok = 'a list

(* Check that recursive definitions don't cause infinite loops or some
   other problem. *)
type unchanged_recursive = [ Cons of (int * unchanged_recursive) | Nil  ]

type unchanged_recursive_a = [ A of unchanged_recursive_b ]
type unchanged_recursive_b = [ B of unchanged_recursive_a ]

(****************************************************************************)
(* Type definitions with possible breaking changes *)
(****************************************************************************)

(* Not detected as a rename but as a deleted/created type name. *)
type new_name_for_root_type = int

(* Undetected incompatibility. Reported as a deleted/created root type name. *)
type new_name_for_root_type_with_changes = {
  x: float;
}
