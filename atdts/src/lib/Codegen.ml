(*
   TypeScript code generation for JSON support (no biniou support)

   Takes the contents of a .atd file and translates it to a .ts file.
   Look into the tests to see what generated code looks like.
*)

open Printf
open Atd.Ast
open Indent
module A = Atd.Ast
module B = Indent

(* Mutable environment holding hash tables and such to avoid
   naming conflicts. *)
type env = {
  (* Global *)
  create_variable: string -> string;
  translate_variable: string -> string;
}

let annot_schema_ts : Atd.Annot.schema_section =
  {
    section = "ts";
    fields = [
      Field, "default";
    ]
  }

let annot_schema : Atd.Annot.schema =
  annot_schema_ts :: Atdgen_emit.Json.annot_schema_json

(* Translate a preferred variable name into an available Python identifier. *)
let trans env id =
  env.translate_variable id

(*
   Convert an ascii string to CamelCase.
   Note that this gets rid of leading and trailing underscores.

   TODO: share the implementation with atdpy?
*)
let to_camel_case s =
  let buf = Buffer.create (String.length s) in
  let start_word = ref true in
  for i = 0 to String.length s - 1 do
    match s.[i] with
    | '_' ->
        start_word := true
    | 'a'..'z' as c when !start_word ->
        Buffer.add_char buf (Char.uppercase_ascii c);
        start_word := false
    | c ->
        Buffer.add_char buf c;
        start_word := false
  done;
  Buffer.contents buf

(* Use CamelCase as customary for type names. *)
let type_name env id =
  trans env (to_camel_case id)

(*
   Create a class identifier that hasn't been seen yet.
   This is for internal disambiguation and still must translated using
   the 'trans' function ('type_name' will not work due to trailing
   underscores being added for disambiguation).
*)
let _create_type_name env name =
  let preferred_id = to_camel_case name in
  env.create_variable preferred_id

let init_env () : env =
  let keywords = [
    (* TODO *)
  ]
  in
  (* Various variables used in the generated code.
     Lowercase variables in this list are superfluous as long as all generated
     variables either start with '_', 'atd_', or an uppercase letter.
  *)
  let reserved_variables = [
    (* TODO *)
  ] in
  let variables =
    Atd.Unique_name.init
      ~reserved_identifiers:(reserved_variables @ keywords)
      ~reserved_prefixes:["atd_"; "_atd_"]
      ~safe_prefix:"x_"
  in
  let create_variable name =
    Atd.Unique_name.create variables name
  in
  let translate_variable id =
    Atd.Unique_name.translate variables id
  in
  {
    create_variable;
    translate_variable;
  }

type quote_kind = Single | Double

(* Escape a string fragment to be placed in single quotes or double quotes. *)
let escape_string_content quote_kind s =
  let buf = Buffer.create (String.length s + 2) in
  for i = 0 to String.length s - 1 do
    match s.[i], quote_kind with
    | '\n', _ -> Buffer.add_string buf "\\n"
    | '\\', _ -> Buffer.add_string buf "\\\\"
    | '\'', Single -> Buffer.add_string buf "\\'"
    | '"', Double -> Buffer.add_string buf "\\\""
    | c, (Single | Double) -> Buffer.add_char buf c
  done;
  Buffer.contents buf

let single_esc s =
  escape_string_content Single s

let double_esc s =
  escape_string_content Double s

let runtime_start atd_filename =
  sprintf {|// Generated by atdts from type definitions in %s.
// Provides type-safe translations from/to JSON.
|}
    atd_filename

let runtime_end = {|
// Runtime library

type Int = number

type Option<T> = null | { Some: T }

function _atd_missing_json_field(type_name: string, json_field_name: string) {
    throw new Error(`missing field '${json_field_name}'` +
                    ` in JSON object of type '${type_name}'`)
}

function _atd_bad_json(expected_type: string, json_value: any) {
  let value_str = String(json_value)
  if (value_str.length > 200)
    value_str = value_str.substring(0, 200) + '…';

  throw new Error(`incompatible JSON value where` +
                  ` type '${expected_type}' was expected: '${value_str}'`)
}

function _atd_bad_ts(expected_type: string, json_value: any) {
  let value_str = String(json_value)
  if (value_str.length > 200)
    value_str = value_str.substring(0, 200) + '…';

  throw new Error(`incompatible TypeScript value where` +
                  ` type '${expected_type}' was expected: '${value_str}'`)
}

function _atd_read_unit(x: any) {
  if (x === null)
    return x
  else
    _atd_bad_json('null', x)
}

function _atd_read_bool(x: any): boolean {
  if (typeof x === 'boolean')
    return x
  else
    _atd_bad_json('boolean', x)
}

function _atd_read_int(x: any): Int {
  if (Number.isInteger(x))
    return x
  else
    _atd_bad_json('integer', x)
}

function _atd_read_float(x: any): number {
  if (isFinite(x))
    return x
  else
    _atd_bad_json('number', x)
}

function _atd_read_string(x: any): string {
  if (typeof x === 'string')
    return x
  else
    _atd_bad_json('str', x)
}

function _atd_read_list<T>(read_elt: (any) => T): (any) => T[] {
  function read_list(elts: any): T[] {
    if (Array.isArray(elts))
      return elts.map(read_elt)
    else
      _atd_bad_json('array', elts)
  }
  return read_list
}

function _atd_write_unit(x: any) {
  if (x === null)
    return x
  else
    _atd_bad_ts('null', x)
}

function _atd_write_bool(x: any): boolean {
  if (typeof x === 'boolean')
    return x
  else
    _atd_bad_ts('boolean', x)
}

function _atd_write_int(x: any): Int {
  if (Number.isInteger(x))
    return x
  else
    _atd_bad_ts('integer', x)
}

function _atd_write_float(x: any): number {
  if (isFinite(x))
    return x
  else
    _atd_bad_ts('number', x)
}

function _atd_write_string(x: any): string {
  if (typeof x === 'string')
    return x
  else
    _atd_bad_ts('string', x)
}

function _atd_write_list<T>(write_elt: (T) => any): (elts: T[]) => any {
  function write_list(elts: T[]): any {
    if (Array.isArray(elts))
      return elts.map(write_elt)
    else
      _atd_bad_json('array', elts)
  }
  return write_list
}
|}

let not_implemented loc msg =
  A.error_at loc ("not implemented in atdts: " ^ msg)

let todo hint =
  failwith ("TODO: " ^ hint)

(* Map ATD built-in types to built-in TypeScript types *)
let ts_type_name env (name : string) =
  match name with
  | "unit" -> "Null"
  | "bool" -> "boolean"
  | "int" -> "Int"
  | "float" -> "number"
  | "string" -> "string"
  | "abstract" -> (* not supported *) "any"
  | user_defined -> type_name env user_defined

let rec type_name_of_expr env (e : type_expr) : string =
  match e with
  | Sum (loc, _, _) -> not_implemented loc "inline sum types"
  | Record (loc, _, _) -> not_implemented loc "inline records"
  | Tuple (loc, xs, an) ->
      let type_names =
        xs
        |> List.map (fun (loc, x, an) -> type_name_of_expr env x)
      in
      sprintf "[%s]" (String.concat ", " type_names)
  | List (loc, e, an) -> sprintf "%s[]" (type_name_of_expr env e)
  | Option (loc, e, an) -> sprintf "Option<%s>" (type_name_of_expr env e)
  | Nullable (loc, e, an) -> type_name_of_expr env e
  | Shared (loc, e, an) -> not_implemented loc "shared"
  | Wrap (loc, e, an) -> todo "wrap"
  | Name (loc, (loc2, name, []), an) -> ts_type_name env name
  | Name (loc, _, _) -> not_implemented loc "parametrized types"
  | Tvar (loc, _) -> not_implemented loc "type variables"

let rec get_default_default (e : type_expr) : string option =
  match e with
  | Sum _
  | Record _
  | Tuple _ (* a default tuple could be possible but we're lazy *) -> None
  | List _ -> Some "[]"
  | Option _ -> Some "Option(None)"
  | Nullable _ -> Some "None"
  | Shared (loc, e, an) -> get_default_default e
  | Wrap (loc, e, an) -> get_default_default e
  | Name (loc, (loc2, name, []), an) ->
      (match name with
       | "unit" -> Some "None"
       | "bool" -> Some "False"
       | "int" -> Some "0"
       | "float" -> Some "0.0"
       | "string" -> Some {|""|}
       | _ -> None
      )
  | Name _ -> None
  | Tvar _ -> None

let get_ts_default (e : type_expr) (an : annot) : string option =
  let user_default = TS_annot.get_ts_default an in
  match user_default with
  | Some s -> Some s
  | None -> get_default_default e

(* If the field is '?foo: bar option', its python or json value has type
   'bar' rather than 'bar option'. *)
let unwrap_field_type loc field_name kind e =
  match kind with
  | Required
  | With_default -> e
  | Optional ->
      match e with
      | Option (loc, e, an) -> e
      | _ ->
          A.error_at loc
            (sprintf "the type of optional field '%s' should be of \
                      the form 'xxx option'" field_name)

let rec json_writer env e =
  match e with
  | Sum (loc, _, _) -> not_implemented loc "inline sum types"
  | Record (loc, _, _) -> not_implemented loc "inline records"
  | Tuple (loc, cells, an) -> tuple_writer env cells
  | List (loc, e, an) -> sprintf "_atd_write_list(%s)" (json_writer env e)
  | Option (loc, e, an) -> sprintf "_atd_write_option(%s)" (json_writer env e)
  | Nullable (loc, e, an) ->
      sprintf "_atd_write_nullable(%s)" (json_writer env e)
  | Shared (loc, e, an) -> not_implemented loc "shared"
  | Wrap (loc, e, an) -> json_writer env e
  | Name (loc, (loc2, name, []), an) ->
      (match name with
       | "bool" | "int" | "float" | "string" -> sprintf "_atd_write_%s" name
       | _ -> "(lambda x: x.to_json())")
  | Name (loc, _, _) -> not_implemented loc "parametrized types"
  | Tvar (loc, _) -> not_implemented loc "type variables"

(*
   Convert python tuple to json list

   (lambda x: [write0(x[0]), write1(x[1])] if isinstance(x, tuple) else error())
*)
and tuple_writer env cells =
  let len = List.length cells in
  let tuple_body =
    List.mapi (fun i (loc, e, an) ->
      sprintf "%s(x[%i])" (json_writer env e) i
    ) cells
    |> String.concat ", "
  in
  sprintf "(lambda x: [%s] \
           if isinstance(x, tuple) and len(x) == %d \
           else _atd_bad_python('tuple of length %d', x))"
    tuple_body
    len len

let _construct_json_field env
    ((loc, (name, kind, an), e) : simple_field) =
  let unwrapped_type = unwrap_field_type loc name kind e in
  let writer_function = json_writer env unwrapped_type in
  let assignment =
    [
      Line (sprintf "res['%s'] = %s(self.%s)"
              (Atdgen_emit.Json.get_json_fname name an |> single_esc)
              writer_function
              (trans env name))
    ]
  in
  match kind with
  | Required
  | With_default -> assignment
  | Optional ->
      [
        Line (sprintf "if self.%s is not None:"
                (trans env name));
        Block assignment
      ]

(*
   Function value that can be applied to a JSON node, converting it
   to the desired value.
*)
let rec json_reader env (e : type_expr) =
  match e with
  | Sum (loc, _, _) -> not_implemented loc "inline sum types"
  | Record (loc, _, _) -> not_implemented loc "inline records"
  | Tuple (loc, cells, an) -> tuple_reader env cells
  | List (loc, e, an) -> sprintf "_atd_read_list(%s)" (json_reader env e)
  | Option (loc, e, an) -> sprintf "_atd_read_option(%s)" (json_reader env e)
  | Nullable (loc, e, an) ->
      sprintf "_atd_read_nullable(%s)" (json_reader env e)
  | Shared (loc, e, an) -> not_implemented loc "shared"
  | Wrap (loc, e, an) -> json_reader env e
  | Name (loc, (loc2, name, []), an) ->
      (match name with
       | "bool" | "int" | "float" | "string" -> sprintf "_atd_read_%s" name
       | _ -> sprintf "%s.from_json" (type_name env name))
  | Name (loc, _, _) -> not_implemented loc "parametrized types"
  | Tvar (loc, _) -> not_implemented loc "type variables"

(*
   Convert json list to python tuple

   (lambda x: (read0(x[0]), read1(x[1])) if isinstance(x, list) else error())
*)
and tuple_reader env cells =
  let len = List.length cells in
  let tuple_body =
    List.mapi (fun i (loc, e, an) ->
      sprintf "%s(x[%i])" (json_reader env e) i
    ) cells
    |> String.concat ", "
  in
  sprintf "(lambda x: (%s) \
           if isinstance(x, list) and len(x) == %d \
           else _atd_bad_json('array of length %d', x))"
    tuple_body
    len len

let _from_json_class_argument
    env ts_type_name ((loc, (name, kind, an), e) : simple_field) =
  let ts_name = trans env name in
  let json_name = Atdgen_emit.Json.get_json_fname name an in
  let unwrapped_type =
    match kind with
    | Required
    | With_default -> e
    | Optional ->
        match e with
        | Option (loc, e, an) -> e
        | _ ->
            A.error_at loc
              (sprintf "the type of optional field '%s' should be of \
                        the form 'xxx option'" name)
  in
  let else_body =
    match kind with
    | Required ->
        sprintf "_atd_missing_json_field('%s', '%s')"
          (single_esc ts_type_name)
          (single_esc json_name)
    | Optional -> "None"
    | With_default ->
        match get_ts_default e an with
        | Some x -> x
        | None ->
            A.error_at loc
              (sprintf "missing default Python value for field '%s'"
                 name)
  in
  sprintf "%s=%s(x['%s']) if '%s' in x else %s,"
    ts_name
    (json_reader env unwrapped_type)
    (single_esc json_name)
    (single_esc json_name)
    else_body

let field_def env ((loc, (name, kind, an), e) : simple_field) =
  let field_name = trans env name in
  let unwrapped_e = unwrap_field_type loc name kind e in
  let type_name = type_name_of_expr env unwrapped_e in
  let optional =
    match kind with
    | Required -> ""
    | Optional -> "?"
    | With_default -> ""
  in
  [
    Line (sprintf "%s%s: %s;" field_name optional type_name)
  ]

let record_type env loc name (fields : field list) an =
  let ts_type_name = type_name env name in
  let fields =
    List.map (function
      | `Field x -> x
      | `Inherit _ -> (* expanded at loading time *) assert false)
      fields
  in
  let field_defs =
    List.map (fun x -> Inline (field_def env x)) fields
  in
  [
    Line (sprintf "export type %s = {" ts_type_name);
    Block field_defs;
    Line "}";
  ]

let alias_type env name type_expr =
  let ts_type_name = type_name env name in
  let value_type = type_name_of_expr env type_expr in
  [
    Line (sprintf "export type %s = %s" ts_type_name value_type)
  ]

let string_of_case_name name =
  sprintf "'%s'" (escape_string_content Single name)

let case_type env type_name (loc, case_name, an, opt_e) =
  let comment =
    let json_name = Atdgen_emit.Json.get_json_cons case_name an in
    if case_name <> json_name then
      sprintf " // JSON: \"%s\"" (double_esc json_name)
    else
      ""
  in
  match opt_e with
  | None ->
      [
        Line (sprintf "| %s%s" (string_of_case_name case_name) comment)
      ]
  | Some e ->
      [
        Line (sprintf "| { kind: %s; value: %s }%s"
                (string_of_case_name case_name)
                (type_name_of_expr env e)
                comment);
      ]

let flatten_variants variants =
  List.map (fun (x : variant) ->
    match x with
    | Variant (loc, (orig_name, an), opt_e) -> (loc, orig_name, an, opt_e)
    | Inherit _ -> assert false
  ) variants

let sum_type env loc name cases =
  let case_types =
    List.map (fun x -> Inline (case_type env name x)) cases
  in
  [
    Line (sprintf "export type %s =" (type_name env name));
    Inline case_types;
  ]

let make_type_def env ((loc, (name, param, an), e) : A.type_def) : B.t =
  if param <> [] then
    not_implemented loc "parametrized type";
  let rec unwrap e =
    match e with
    | Sum (loc, variants, an) ->
        sum_type env loc name (flatten_variants variants)
    | Record (loc, fields, an) ->
        record_type env loc name fields an
    | Tuple _
    | List _
    | Option _
    | Nullable _
    | Name _ -> alias_type env name e
    | Shared _ -> not_implemented loc "cyclic references"
    | Wrap (loc, e, an) -> unwrap e
    | Tvar _ -> not_implemented loc "parametrized type"
  in
  unwrap e

let writer_name _env name =
  name ^ "_to_JSON"

let make_writer env loc name an e =
  let type_ = type_name env name in
  let ts_name = writer_name env name in
  [
    Line (sprintf "function %s(): %s {" ts_name type_);
    Block [];
    Line "}";
  ]

let make_functions env ((loc, (name, param, an), e) : A.type_def) : B.t =
  if param <> [] then
    not_implemented loc "parametrized type";
  let writer = make_writer env loc name an e in
  let reader = [] in
  [
    Inline writer;
    Inline reader;
  ]

(*
   Make sure that the types as defined in the atd file get a good name.
   For example, type 'foo' should become class 'Foo'.
   We do this because each case constructor of sum types will also
   translate to a class in the same namespace. For example,
   there may be a type like 'type bar = [ Foo | Bleep ]'.
   We want to ensure that the type 'foo' gets the name 'Foo' and that only
   later the case 'Foo' gets a lesser name like 'Foo_' or 'Foo2'.
*)
let reserve_good_type_names env (items: A.module_body) =
  List.iter
    (fun (Type (loc, (name, param, an), e)) -> ignore (type_name env name))
    items

let to_file ~atd_filename (items : A.module_body) dst_path =
  let env = init_env () in
  let atd_defs = List.map (fun (Type x) -> x) items in
  reserve_good_type_names env items;
  let type_defs =
    List.map (fun x -> Inline (make_type_def env x)) atd_defs
  in
  let functions =
    List.map (fun x ->
      Inline (make_functions env x)
    ) atd_defs
  in
  [
    Line (runtime_start atd_filename);
    Inline type_defs;
    Inline functions;
    Line runtime_end;
  ]
  |> Indent.to_file ~indent:2 dst_path

let run_file src_path =
  let src_name = Filename.basename src_path in
  let dst_name =
    (if Filename.check_suffix src_name ".atd" then
       Filename.chop_suffix src_name ".atd"
     else
       src_name) ^ ".ts"
    |> String.lowercase_ascii
  in
  let dst_path = dst_name in
  let (atd_head, atd_module), _original_types =
    Atd.Util.load_file
      ~annot_schema
      ~expand:false ~inherit_fields:true ~inherit_variants:true src_path
  in
  to_file ~atd_filename:src_name atd_module dst_path
