// Generated by atdts from type definitions in everything.atd.
// Provides type-safe translations from/to JSON.

export type Kind =
| 'Root'
| { kind: 'Thing'; value: Int }
| 'WOW' // JSON: "wow"
| { kind: 'Amaze'; value: string[] } // JSON: "!!!"
export type Root = {
  id: string;
  items: Int[][];
  maybe?: Int;
  extras: Int[];
  answer: Int;
  aliased: Alias;
  point: [number, number];
  kinds: Kind[];
  assoc1: [number, Int][];
}
export type Alias = Int[]
export type Pair = [string, Int]

// Runtime library

type Int = number

type Option<T> = null | { Some: T }

function _atd_missing_json_field(type_name: string, json_field_name: string) {
    throw new Error(`missing field '${json_field_name}'` +
                    ` in JSON object of type '${type_name}'`)
}

function _atd_bad_json(expected_type: string, json_value: any) {
  let value_str = String(json_value)
  if (value_str.length > 200)
    value_str = value_str.substring(0, 200) + '…';

  throw new Error(`incompatible JSON value where` +
                  ` type '${expected_type}' was expected: '${value_str}'`)
}

function _atd_bad_ts(expected_type: string, json_value: any) {
  let value_str = String(json_value)
  if (value_str.length > 200)
    value_str = value_str.substring(0, 200) + '…';

  throw new Error(`incompatible TypeScript value where` +
                  ` type '${expected_type}' was expected: '${value_str}'`)
}

function _atd_read_unit(x: any) {
  if (x === null)
    return x
  else
    _atd_bad_json('null', x)
}

function _atd_read_bool(x: any): boolean {
  if (typeof x === 'boolean')
    return x
  else
    _atd_bad_json('boolean', x)
}

function _atd_read_int(x: any): Int {
  if (Number.isInteger(x))
    return x
  else
    _atd_bad_json('integer', x)
}

function _atd_read_float(x: any): number {
  if (isFinite(x))
    return x
  else
    _atd_bad_json('number', x)
}

function _atd_read_string(x: any): string {
  if (typeof x === 'string')
    return x
  else
    _atd_bad_json('str', x)
}

function _atd_read_list<T>(read_elt: (any) => T): (any) => T[] {
  function read_list(elts: any): T[] {
    if (Array.isArray(elts))
      return elts.map(read_elt)
    else
      _atd_bad_json('array', elts)
  }
  return read_list
}

function _atd_write_unit(x: any) {
  if (x === null)
    return x
  else
    _atd_bad_ts('null', x)
}

function _atd_write_bool(x: any): boolean {
  if (typeof x === 'boolean')
    return x
  else
    _atd_bad_ts('boolean', x)
}

function _atd_write_int(x: any): Int {
  if (Number.isInteger(x))
    return x
  else
    _atd_bad_ts('integer', x)
}

function _atd_write_float(x: any): number {
  if (isFinite(x))
    return x
  else
    _atd_bad_ts('number', x)
}

function _atd_write_string(x: any): string {
  if (typeof x === 'string')
    return x
  else
    _atd_bad_ts('string', x)
}

function _atd_write_list<T>(write_elt: (T) => any): (elts: T[]) => any {
  function write_list(elts: T[]): any {
    if (Array.isArray(elts))
      return elts.map(write_elt)
    else
      _atd_bad_json('array', elts)
  }
  return write_list
}

