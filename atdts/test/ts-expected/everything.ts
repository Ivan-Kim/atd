// Generated by atdts from type definitions in 'everything.atd'.
//
// Type-safe translations from/to JSON
//
// For each type 'Foo', there is a pair of functions:
// - 'writeFoo': convert a 'Foo' value into a JSON-compatible value
//   of type 'any'.
// - 'readFoo': convert a JSON-compatible value into a TypeScript value
//   of type 'Foo'.


export type DifferentKindsOfThings =
| { kind: 'Root' }
| { kind: 'Thing'; value: Int }
| { kind: 'WOW' } // JSON: "wow"
| { kind: 'Amaze'; value: string[] } // JSON: "!!!"

export type Root = {
  id: string;
  items: Int[][];
  maybe?: Int;
  extras: Int[];
  answer: Int;
  aliased: Alias;
  point: [number, number];
  kinds: DifferentKindsOfThings[];
  assoc1: [number, Int][];
  options: Option<Int>[];
  nullables: Int[];
}

export type Alias = Int[]

export type Pair = [string, Int]

export function writeDifferentKindsOfThings(x: DifferentKindsOfThings): any {
  switch (x.kind) {
    case 'Root':
      return 'Root'
    case 'Thing':
      return ['Thing', _atd_write_int(x.value)]
    case 'WOW':
      return 'wow'
    case 'Amaze':
      return ['!!!', _atd_write_list(_atd_write_string)(x.value)]
  }
}

export function readDifferentKindsOfThings(x: any): DifferentKindsOfThings {
  if (typeof x === 'string') {
    switch (x) {
      case 'Root':
        return { kind: 'Root' }
      case 'wow':
        return { kind: 'WOW' }
      default:
        _atd_bad_json('DifferentKindsOfThings', x)
    }
  }
  else {
    _atd_check_json_tuple(2, x)
    switch (x[1]) {
      case 'Thing':
        return { kind: 'Thing', value: _atd_write_int(x[1]) }
      case '!!!':
        return { kind: 'Amaze', value: _atd_write_list(_atd_write_string)(x[1]) }
      default:
        _atd_bad_json('DifferentKindsOfThings', x)
    }
  }
}

export function writeRoot(x: Root): any {
  return {
    ID: _atd_write_string(x.id),
    items: _atd_write_list(_atd_write_list(_atd_write_int))(x.items),
    maybe: _atd_write_int(x.maybe),
    extras: _atd_write_list(_atd_write_int)(x.extras),
    answer: _atd_write_int(x.answer),
    aliased: writeAlias(x.aliased),
    point: ((x) => [_atd_write_float(x[0]), _atd_write_float(x[1])])(x.point),
    kinds: _atd_write_list(writeDifferentKindsOfThings)(x.kinds),
    assoc1: _atd_write_list(((x) => [_atd_write_float(x[0]), _atd_write_int(x[1])]))(x.assoc1),
    options: _atd_write_list(_atd_write_option(_atd_write_int))(x.options),
    nullables: _atd_write_list(_atd_write_int)(x.nullables),
  };
}

export function readRoot(x: any): Root {
  return {
    id: _atd_read_string(x['ID']),
    items: _atd_read_list(_atd_read_list(_atd_read_int))(x['items']),
    maybe: _atd_read_optional_field(_atd_read_int, x['maybe']),
    extras: _atd_read_field_with_default(_atd_read_list(_atd_read_int), [], x['extras']),
    answer: _atd_read_field_with_default(_atd_read_int, 42, x['answer']),
    aliased: readAlias(x['aliased']),
    point: ((x): [number, number] => { _atd_check_json_tuple(2, x); return [_atd_read_float(x[0]), _atd_read_float(x[1])] })(x['point']),
    kinds: _atd_read_list(readDifferentKindsOfThings)(x['kinds']),
    assoc1: _atd_read_list(((x): [number, Int] => { _atd_check_json_tuple(2, x); return [_atd_read_float(x[0]), _atd_read_int(x[1])] }))(x['assoc1']),
    options: _atd_read_field_with_default(_atd_read_list(_atd_read_option(_atd_read_int)), [], x['options']),
    nullables: _atd_read_field_with_default(_atd_read_list(_atd_read_nullable(_atd_read_int)), [], x['nullables']),
  };
}

export function writeAlias(x: Alias): any {
  return _atd_write_list(_atd_write_int)(x);
}

export function readAlias(x: any): Alias {
  return _atd_read_list(_atd_read_int)(x);
}

export function writePair(x: Pair): any {
  return ((x) => [_atd_write_string(x[0]), _atd_write_int(x[1])])(x);
}

export function readPair(x: any): Pair {
  return ((x): [string, Int] => { _atd_check_json_tuple(2, x); return [_atd_read_string(x[0]), _atd_read_int(x[1])] })(x);
}


/////////////////////////////////////////////////////////////////////
// Runtime library
/////////////////////////////////////////////////////////////////////

type Int = number

type Option<T> = null | { value: T }

function _atd_missing_json_field(type_name: string, json_field_name: string) {
    throw new Error(`missing field '${json_field_name}'` +
                    ` in JSON object of type '${type_name}'`)
}

function _atd_bad_json(expected_type: string, json_value: any) {
  let value_str = String(json_value)
  if (value_str.length > 200)
    value_str = value_str.substring(0, 200) + '…';

  throw new Error(`incompatible JSON value where` +
                  ` type '${expected_type}' was expected: '${value_str}'`)
}

function _atd_bad_ts(expected_type: string, json_value: any) {
  let value_str = String(json_value)
  if (value_str.length > 200)
    value_str = value_str.substring(0, 200) + '…';

  throw new Error(`incompatible TypeScript value where` +
                  ` type '${expected_type}' was expected: '${value_str}'`)
}

function _atd_check_json_tuple(len: Int, x: any) {
  if (! Array.isArray(x) || x.length !== len)
    _atd_bad_json('tuple of length ' + len, x);
}

function _atd_read_unit(x: any) {
  if (x === null)
    return x
  else
    _atd_bad_json('null', x)
}

function _atd_read_bool(x: any): boolean {
  if (typeof x === 'boolean')
    return x
  else
    _atd_bad_json('boolean', x)
}

function _atd_read_int(x: any): Int {
  if (Number.isInteger(x))
    return x
  else
    _atd_bad_json('integer', x)
}

function _atd_read_float(x: any): number {
  if (isFinite(x))
    return x
  else
    _atd_bad_json('number', x)
}

function _atd_read_string(x: any): string {
  if (typeof x === 'string')
    return x
  else
    _atd_bad_json('str', x)
}

function _atd_read_optional_field<T>(read_elt: (x: any) => T,
                                     x: any): T {
  if (x === undefined || x === null)
    return null
  else
    return read_elt(x)
}

function _atd_read_field_with_default<T>(read_elt: (x: any) => T,
                                         default_: T,
                                         x: any): T {
  if (x === undefined || x === null)
    return default_
  else
    return read_elt(x)
}

function _atd_read_option<T>(read_elt: (x: any) => T):
  (x: any) => Option<T> {
  function read_option(x: any): Option<T> {
    if (x === 'None')
      return null
    else {
      _atd_check_json_tuple(2, x);
      switch (x[0]) {
        case 'Some':
          return { value: read_elt(x[0]) }
        default:
           _atd_bad_json('option', x)
      }
    }
  }
  return read_option
}

function _atd_read_nullable<T>(read_elt: (x: any) => T):
  (x: any) => T {
  function read_nullable(x: any): T {
    if (x === null)
      return null
    else
      return read_elt(x)
  }
  return read_nullable
}

function _atd_read_list<T>(read_elt: (x: any) => T): (elts: any) => T[] {
  function read_list(elts: any): T[] {
    if (Array.isArray(elts))
      return elts.map(read_elt)
    else
      _atd_bad_json('array', elts)
  }
  return read_list
}

function _atd_write_unit(x: any) {
  if (x === null)
    return x
  else
    _atd_bad_ts('null', x)
}

function _atd_write_bool(x: any): boolean {
  if (typeof x === 'boolean')
    return x
  else
    _atd_bad_ts('boolean', x)
}

function _atd_write_int(x: any): Int {
  if (Number.isInteger(x))
    return x
  else
    _atd_bad_ts('integer', x)
}

function _atd_write_float(x: any): number {
  if (isFinite(x))
    return x
  else
    _atd_bad_ts('number', x)
}

function _atd_write_string(x: any): string {
  if (typeof x === 'string')
    return x
  else
    _atd_bad_ts('string', x)
}

function _atd_write_option<T>(write_elt: (x: T) => any):
   (elts: Option<T>) => any {
  function write_option(x: Option<T>): any {
    if (x === null)
      return 'None'
    else
      return ['Some', write_elt(x.value)]
  }
  return write_option
}

function _atd_write_nullable<T>(write_elt: (x: T) => any): (elts: T) => any {
  function write_option(x: T): any {
    if (x === null)
      return null
    else
      return write_elt(x)
  }
  return write_option
}

function _atd_write_list<T>(write_elt: (elt: T) => any): (elts: T[]) => any {
  return ((elts: T[]): any => elts.map(write_elt))
}

