open Printf
open Atd.Ast
open Indent
module A = Atd.Ast
module B = Indent

let annot_schema_ts : Atd.Annot.schema_section =
  {
    section = "ts";
    fields = [
      Type_expr, "repr";
      Field, "default";
    ]
  }

let spaced ?(spacer = [Line ""]) (blocks : B.node list) : B.node list =
  let rec spaced xs =
    match List.filter (fun x -> not (B.is_empty_node x)) xs with
    | []
    | [_] as xs -> xs
    | a :: rest -> a :: spacer @ spaced rest
  in
  spaced blocks

let get_default (e : type_expr) : string option = 
  match e with
  | Sum _
  | Record _
  | Tuple _ -> None
  | List _ -> Some "{}"
  | Option _ -> Some "std::nullopt"
  | _ -> A.error "Unsupported default type"

let cpp_type_name name : string = 
  match name with 
  | "unit" -> "void"
  | "bool" -> "bool"
  | "int" -> "int"
  | "float" -> "float"
  | _ -> A.error (Printf.sprintf "Unsupported type %s" name)

let file_start name = 
  let guard_name = Util.prepare_header_guard name in
  sprintf {|/*
 * Automatically generated by ATD from file '%s'
 */

#ifndef %s_HPP
#define %s_HPP

#include <string>
#include <optional>
#include <memory>
#include <variant>
 |}
  name guard_name guard_name

let file_end =
  "\n#endif"

 let not_implemented loc msg =
   A.error_at loc ("not implemented in atdcpp: " ^ msg)

let rec unwrap e =
  match e with
  | Wrap (loc, e, an) -> unwrap e
  | Shared (loc, e, an) -> not_implemented loc "cyclic references"
  | Tvar (loc, name) -> not_implemented loc "parametrized type"
  | Sum _
  | Record _
  | Tuple _
  | List _
  | Option _
  | Nullable _
  | Name _ -> e

type assoc_kind = 
  | Array_array
  | Array_map of type_expr * type_expr
  | Object_map of type_expr
  | Object_array of type_expr

type assoc_repr = 
  | Array
  | Map

let get_cpp_assoc_repr an : assoc_repr = 
  Atd.Annot.get_field
    ~parse:(function 
      | "array" -> Some Array
      | "map" -> Some Map
      | _ -> None
    )
    ~default:Array
    ~sections:["cpp"]
    ~field:"repr"
    an

let assoc_kind loc (e : type_expr) an : assoc_kind =
  let json_repr = Atd.Json.get_json_list an in
  let ts_repr = get_cpp_assoc_repr an in
  match e, json_repr, ts_repr with
  | Tuple (loc, [(_, key, _); (_, value, _)], an2), Array, Map ->
      Array_map (key, value)
  | Tuple (loc,
            [(_, Name (_, (_, "string", _), _), _); (_, value, _)], an2),
    Object, Map ->
      Object_map value
  | Tuple (loc,
            [(_, Name (_, (_, "string", _), _), _); (_, value, _)], an2),
    Object, Array -> Object_array value
  | _, Array, Array -> Array_array
  | _, Object, _ -> error_at loc "not a (string * _) list"
  | _, Array, _ -> error_at loc "not a (_ * _) list"

let reserve_good_type_names env (items: A.module_body) =
  List.iter
    (fun (Type (loc, (name, param, an), e)) -> ignore (Env.type_name env name))
    items

let to_file ~atd_filename (items : A.module_body) dst_path =
  let env = Env.init_env () in
  let atd_defs = List.map (fun (Type x) -> x) items in
  let type_defs = List.map(fun x -> Block (Types.make_type_def env x)) atd_defs in
  [
    Line (file_start atd_filename);
    Block (spaced type_defs);
    Line (file_end)
  ] |>
  (* |> spaced *)
  Indent.write_file dst_path

let annot_schema : Atd.Annot.schema =
  annot_schema_ts :: Atd.Json.annot_schema_json

let run_file src_path =
  let src_name = Filename.basename src_path in
  let dst_name =
    (if Filename.check_suffix src_name ".atd" then
       Filename.chop_suffix src_name ".atd"
     else
       src_name) ^ ".hpp"
    |> String.lowercase_ascii
  in
  let dst_path = dst_name in
  let (atd_head, atd_module), _original_types =
    Atd.Util.load_file
      ~annot_schema
      ~expand:false ~inherit_fields:true ~inherit_variants:true src_path
  in
  to_file ~atd_filename:src_name atd_module dst_path
