open Printf
open Atd.Ast
open Indent
module A = Atd.Ast
module B = Indent

(* Mutable environment holding hash tables and such to avoid
  naming conflicts. *)
type env = {
  (* Global *)
  create_variable: string -> string;
  translate_variable: string -> string;
}

let annot_schema_ts : Atd.Annot.schema_section =
  {
    section = "ts";
    fields = [
      Type_expr, "repr";
      Field, "default";
    ]
  }

let get_default (e : type_expr) : string option = 
  match e with
  | Sum _
  | Record _
  | Tuple _ -> None
  | List _ -> Some "{}"
  | Option _ -> Some "std::nullopt"
  | _ -> A.error "Unsupported default type"

let cpp_type_name name : string = 
  match name with 
  | "unit" -> "void"
  | "bool" -> "bool"
  | "int" -> "int"
  | "float" -> "float"
  | _ -> A.error (Printf.sprintf "Unsupported type %s" name)

let file_start name = 
  sprintf {|/*
 * Automatically generated by ATD from file '%s'
 */ |}
  name

 let not_implemented loc msg =
   A.error_at loc ("not implemented in atdts: " ^ msg)

let rec unwrap e =
  match e with
  | Wrap (loc, e, an) -> unwrap e
  | Shared (loc, e, an) -> not_implemented loc "cyclic references"
  | Tvar (loc, name) -> not_implemented loc "parametrized type"
  | Sum _
  | Record _
  | Tuple _
  | List _
  | Option _
  | Nullable _
  | Name _ -> e

type assoc_kind = 
  | Array_array
  | Array_map of type_expr * type_expr
  | Object_map of type_expr
  | Object_array of type_expr

type assoc_repr = 
  | Array
  | Map

let get_cpp_assoc_repr an : assoc_repr = 
  Atd.Annot.get_field
    ~parse:(function 
      | "array" -> Some Array
      | "map" -> Some Map
      | _ -> None
    )
    ~default:Array
    ~sections:["cpp"]
    ~field:"repr"
    an

let assoc_kind loc (e : type_expr) an : assoc_kind =
  let json_repr = Atd.Json.get_json_list an in
  let ts_repr = get_cpp_assoc_repr an in
  match e, json_repr, ts_repr with
  | Tuple (loc, [(_, key, _); (_, value, _)], an2), Array, Map ->
      Array_map (key, value)
  | Tuple (loc,
            [(_, Name (_, (_, "string", _), _), _); (_, value, _)], an2),
    Object, Map ->
      Object_map value
  | Tuple (loc,
            [(_, Name (_, (_, "string", _), _), _); (_, value, _)], an2),
    Object, Array -> Object_array value
  | _, Array, Array -> Array_array
  | _, Object, _ -> error_at loc "not a (string * _) list"
  | _, Array, _ -> error_at loc "not a (_ * _) list"

let rec type_name_of_expr env (e : type_expr) : string =
  match e with
  | Sum (loc, _, _) -> not_implemented loc "inline sum types"
  | Record (loc, _, _) -> not_implemented loc "inline records"
  | Tuple (loc, cells, an) -> not_implemented loc "tuple"
  | List (loc, e, an) ->
      (match assoc_kind loc e an with
        | Array_array
        | Object_array _ ->
            sprintf "%s[]"
              (type_name_of_expr env e)
        | Array_map (key, value) ->
            sprintf "Map<%s, %s>"
              (type_name_of_expr env key) (type_name_of_expr env value)
        | Object_map value ->
            sprintf "Map<string, %s>"
              (type_name_of_expr env value)
      )
  | Option (loc, e, an) -> sprintf "Option<%s>" (type_name_of_expr env e)
  | Nullable (loc, e, an) -> sprintf "(%s | null)" (type_name_of_expr env e)
  | Shared (loc, e, an) -> not_implemented loc "shared"
  | Wrap (loc, e, an) -> not_implemented loc "wrap"
  | Name (loc, (loc2, name, []), an) -> cpp_type_name name
  | Name (loc, _, _) -> not_implemented loc "parametrized types"
  | Tvar (loc, _) -> not_implemented loc "type variables"

let alias_type env name type_expr = 
  let cpp_type_name = cpp_type_name name in
  let value_type = type_name_of_expr env type_expr in
  [
    Line (sprintf "using %s = %s" cpp_type_name value_type)
  ]

let make_type_def env ((loc, (name, param, an), e) : A.type_def) : B.t =
  if param <> [] then
    not_implemented loc "parametrized type";
  match unwrap e with 
  | Sum _
    (* sum_type env loc name (flatten_variants variants) *)
  | Record _ ->
      (* record_type env loc name fields an *)
      not_implemented loc "Sum or record type"
  | Tuple _
  | List _
  | Option _
  | Nullable _
  | Name _ -> alias_type env name e
  | Shared (loc, e, an) -> assert false
  | Wrap (loc, e, an) -> assert false
  | Tvar _ -> assert false

let init_env () : env =
  (* The list of "keywords" is extracted from
      https://en.cppreference.com/w/cpp/keyword
  *)
  let keywords = [
    (* Reserved Words *)
    "alignas"; "alignof"; "and"; "and_eq"; "asm"; "atomic_cancel"; 
    "atomic_commit"; "atomic_noexcept"; "auto"; "bitand"; "bitor"; 
    "bool"; "break"; "case"; "catch"; "case"; "catch"; "char";
    "char8_t"; "char16_t"; "char32_t"; "class"; "compl"; "concept"; 
    "const"; "consteval"; "constexpr"; "constinit"; "const_cast";
    "continue"; "co_await"; "co_return"; "co_yield"; "decltype"; 
    "default"; "delete"; "do"; "double"; "dynamic_cast"; "else";
    "enum"; "explicit"; "export"; "extern"; "false"; "float"; "for";
    "friend"; "goto"; "if"; "inline"; "int"; "long"; "mutable";
    "namespace"; "new"; "noexcept"; "not"; "not_eq"; "nullptr";
    "operator"; "or"; "or_eq"; "private"; "protected"; "public";
    "reflexpr"; "register"; "reinterpret_cast"; "requires"; "return";
    "short"; "signed"; "signed"; "sizeof"; "static"; "static_assert";
    "static_cast"; "struct"; "switch"; "synchronized"; "template";
    "this"; "thread_local"; "throw"; "true"; "try"; "typedef";
    "typeid"; "typename"; "union"; "unsigned"; "using"; "virtual";
    "void"; "volatile"; "wchar_t"; "while"; "xor"; "xor_eq";
  ]
  in
  (* Various variables used in the generated code. *)
  let reserved_variables = [
    (* fill this thoroughly when we start using user-named variables *)
    "x"
  ] in
  let variables =
    Atd.Unique_name.init
      ~reserved_identifiers:(reserved_variables @ keywords)
      ~reserved_prefixes:["atd_"; "_atd_"]
      ~safe_prefix:"x_"
  in
  let create_variable name =
    Atd.Unique_name.create variables name
  in
  let translate_variable id =
    Atd.Unique_name.translate variables id
  in
  {
    create_variable;
    translate_variable;
  }

let type_name env name = 
  env.translate_variable name

let reserve_good_type_names env (items: A.module_body) =
  List.iter
    (fun (Type (loc, (name, param, an), e)) -> ignore (type_name env name))
    items

let to_file ~atd_filename (items : A.module_body) dst_path =
  (* let env = init_env () in *)
  let atd_defs = List.map (fun (Type x) -> x) items in
  (* reserve_good_type_names env items; *)
  (* let type_defs = *)
    (* List.map (fun x -> Inline (make_type_def env x)) atd_defs *)
  (* in *)
  (* let functions = *)
    (* List.map (fun x -> *)
      (* Inline (make_functions env x) *)
    (* ) atd_defs *)
  (* in *)
  [
    Line (file_start atd_filename);
    (* Inline (spaced type_defs); *)
    (* Inline (spaced functions); *)
  ] |>
  (* |> spaced *)
  Indent.write_file dst_path

let annot_schema : Atd.Annot.schema =
  annot_schema_ts :: Atd.Json.annot_schema_json

let run_file src_path =
  let src_name = Filename.basename src_path in
  let dst_name =
    (if Filename.check_suffix src_name ".atd" then
       Filename.chop_suffix src_name ".atd"
     else
       src_name) ^ ".hpp"
    |> String.lowercase_ascii
  in
  let dst_path = dst_name in
  let (atd_head, atd_module), _original_types =
    Atd.Util.load_file
      ~annot_schema
      ~expand:false ~inherit_fields:true ~inherit_variants:true src_path
  in
  to_file ~atd_filename:src_name atd_module dst_path
